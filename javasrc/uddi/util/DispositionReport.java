/* * jUDDI - An open source Java implementation of UDDI v2.0 * http://juddi.org/ * * Copyright (c) 2002, Steve Viens and contributors * All rights reserved. */package psl.discus.javasrc.uddi.util;import org.w3c.dom.Element;import org.w3c.dom.NodeList;import org.uddi4j.UDDIException;import org.uddi4j.response.ErrInfo;import org.uddi4j.response.Result;import java.util.Vector;/** * Represents an UDDI defined error. This object is returned from certain * UDDI API calls. Other UDDI APIs return a data object if success and * generate a fault message if failure. The API returns the fault * by throwing a UDDIException.<P> * * UDDIException usually contains a Disposition report that has detailed * information about the UDDI error as defined by the UDDI specification. * If the response is a SOAP fault, but does not contains a disposition * report, a UDDIException may be thrown without containing a * DispositionReport.<P> * * This class contains defines for the various error values * that can be returned.<P> * * @author  Steve Viens * @version 0.6 */public class DispositionReport extends org.uddi4j.UDDIElement{  public static String UDDI_TAG = "dispositionReport";  // XML attributes. Looks common to all message responses  String generic  = null;  String operator = null;  // Vector of Result objects/elements  Vector resultVector = new Vector();  /* Defines of possible error codes that can be returned */  /**   * Signifies that a particular publisher assertion (consisting of two   * businessKey values, and a keyed reference with three components)   * cannot be identified in a save or delete operation.   */  public static final String E_assertionNotFound = "E_assertionNotFound";  /**   * Signifies that the authentication token value passed in the authInfo   * argument is no longer valid because the token has expired.   */  public static final String E_authTokenExpired = "E_authTokenExpired";  /**   * Signifies that the authentication token value passed in the   * authInfo argument is either missing or is not valid.   */  public static final String E_authTokenRequired = "E_authTokenRequired";  /**   * Signifies that user account limits have been exceeded.   */  public static final String E_accountLimitExceeded = "E_accountLimitExceeded";  /**   * Signifies that the request cannot be processed at the current time.   */  public static final String E_busy = "E_busy";  /**   * Restrictions have been placed by the taxonomy provider on the   * types of information that should be included at that location   * within a specific taxonomy.  The validation routine chosen by   * the Operator Site has rejected this tModel for at least one   * specified category.   */  public static final String E_categorizationNotAllowed = "E_categorizationNotAllowed";  /**   * Signifies that a serious technical error has occurred while   * processing the request.   */  public static final String E_fatalError= "E_fatalError";  /**   * Signifies that the request cannot be satisfied because one   * or more uuid_key values specified is not a valid key value.   * This will occur if a uuid_key value is passed in a tModel   * that does not match with any known tModel key.   */  public static final String E_invalidKeyPassed = "E_invalidKeyPassed";  /**   * Signifies that an attempt was made to save a businessEntity   * containing a service projection that does not match the   * businessService being projected. The serviceKey of at least one   * such businessService will be included in the dispositionReport   */  public static final String E_invalidProjection = "E_invalidProjection";  /**   * Signifies that the given keyValue did not correspond to a   * category within the taxonomy identified by a tModelKey value   * within one of the categoryBag elements provided.   */  public static final String E_invalidCategory = "E_invalidCategory";  /**   * Signifies that one of assertion status values passed is   * unrecognized.  The completion status that caused the problem   * will be clearly indicated in the error text.   */  public static final String E_invalidCompletionStatus = "E_invalidCompletionStatus";  /**   * An error occurred with one of the uploadRegister URL values.   */  public static final String E_invalidURLPassed = "E_invalidURLPassed";  /**   * A value that was passed in a keyValue attribute did not pass   * validation.  This applies to checked categorizations, identifiers   * and other validated code lists. The error text will clearly   * indicate the key and value combination that failed validation.   */  public static final String E_invalidValue = "E_invalidValue";  /**   * Signifies that the request cannot be satisfied because one   * or more uuid_key values specified has previously been hidden   * or removed by the requester. This specifically applies to the   * tModelKey values passed.   */  public static final String E_keyRetired = "E_keyRetired";  /**   * Signifies that an error was detected while processing elements   * that were annotated with xml:lang qualifiers. Presently, only the   * description and name elements support xml:lang qualifications.   */  public static final String E_languageError = "E_languageError";  /**   * Signifies that the message it too large.  The upper limit   * will be clearly indicated in the error text.   */  public static final String E_messageTooLarge = "E_messageTooLarge";  /**   * Signifies that the partial name value passed exceeds the   * maximum name length designated by the policy of an implementation   * or Operator Site.   */  public static final String E_nameTooLong = "E_nameTooLong";  /**   * Signifies that one or more of the uuid_key values passed   * refers to data that is not controlled by the Operator Site   * that received the request for processing.   */  public static final String E_operatorMismatch = "E_operatorMismatch";  /**   * Signifies that the target publisher cancelled the custody   * transfer operation.   */  public static final String E_publisherCancelled = "E_publisherCancelled";  /**   * Signifies that a custody transfer request has been refused.   */  public static final String E_requestDenied = "E_requestDenied";  /**   * Signifies that the request could not be carried out because   * a needed validate_values service did not respond in a   * reasonable amount of time.   */  public static final String E_requestTimeout = "E_requestTimeout";  /**   * Signifies that the target publisher was unable to match the   * shared secret and the five (5) attempt limit was exhausted. The   * target operator automatically cancelled the transfer operation.   */  public static final String E_secretUnknown = "E_secretUnknown";  /**   * Signifies no failure occurred. This return code is used with   * the dispositionReport for reporting results from requests with   * no natural response document.   */  public static final String E_success = "E_success";  /**   * Signifies that too many or incompatible arguments were   * passed. The error text will clearly indicate the nature of   * the problem.   */  public static final String E_tooManyOptions = "E_tooManyOptions";  /**   * Signifies that a custody transfer request will not succeed.   */  public static final String E_transferAborted = "E_transferAborted";  /**   * Signifies that the value of the generic attribute passed   * is unsupported by the Operator Instance being queried.   */  public static final String E_unrecognizedVersion = "E_unrecognizedVersion";  /**   * Signifies that the user ID and password pair passed in a   * get_authToken message is not known to the Operator Site or   * is not valid.   */  public static final String E_unknownUser = "E_unknownUser";  /**   * Signifies that the implementer does not support a feature   * or API.   */  public static final String E_unsupported = "E_unsupported";  /**   * Signifies that an attempt was made to reference a taxonomy   * or identifier system in a keyedReference whose tModel is   * categorized with the unvalidatable categorization.   */  public static final String E_unvalidatable = "E_unvalidatable";  /**   * Signifies that one or more of the uuid_key values passed   * refers to data that is not controlled by the individual who   * is represented by the authentication token.   */  public static final String E_userMismatch = "E_userMismatch";  /**   * Signifies that a value did not pass validation because of   * contextual issues. The value may be valid in some contexts,   * but not in the context used. The error text may contain   * information about the contextual problem.   */  public static final String E_valueNotAllowed = "E_valueNotAllowed";  /**   * Default constructor   */  public DispositionReport()  {  }  /**   * Constructer that parses the XML DOM tree and extracts   * useful attributes.   *   * @param el Root element of the tree within the SOAP body.   */  public DispositionReport(Element el) throws UDDIException  {    boolean fault = false ;    UDDIException exception = null;    if (UDDIException.isValidElement(el)) {      // If it is a SOAPFault, then there most likely is a Disposition      // report. If it is not present then the UDDIException constructor      // will handle it.      fault = true;      exception = new UDDIException(el,true);      NodeList nl = exception.getDetailElement().getElementsByTagName(UDDI_TAG);      if (nl.getLength()>0)        base = (Element)nl.item(0);      else // not a disposition report, some other error, throw it        throw exception;    }    else      base = el;    if (isValidElement(base)) {      // extract 'generic' and 'operator' attribute values      this.generic = el.getAttribute("generic");      this.operator = el.getAttribute("operator");      // process embedded 'result' elements      NodeList nl = el.getElementsByTagName("result");      for (int i=0; i<nl.getLength(); i++) {        if (resultVector == null)          resultVector = new Vector();        resultVector.add(new Result((Element)nl.item(i)));      }    }    if(fault)      throw exception;  }  /**   * Returns the value of the DispositionReport's "generic" attribute.   *   * @see #setGeneric(java.lang.String)   */  public String getGeneric()  {    return this.generic;  }  /**   * Returns the value of the DispositionReport's "operator" attribute.   *   * @see #setOperator(java.lang.String)   */  public String getOperator()  {    return this.operator;  }  /**   * Returns a Vector of all result elements in the DispositionReport.   *   * @see #setResults(java.util.Vector)   */  public Vector getResults()  {    return this.resultVector;  }  /**   * Returns the value of the "errno" attribute from the first   * result in the DispositionReport. Same as calling getErrno(0).   * Will throw an ArrayIndexOutOfBoundsException if the results    * Vector is empty.   *   * @see #getErrno(int)   */  public int getErrno()  {    return getErrno(0);  }  /**   * Returns the value of the "errCode" attribute of the ErrInfo   * element from the first result of the DispositionReport. Same     * as calling getErrCode(0). Will throw an ArrayIndexOutOfBoundsException    * if the results Vector is empty.   *   * @see #getErrCode(int)   */  public String getErrCode()  {    return getErrCode(0);  }  /**   * Returns the text value of the ErrInfo object from the   * first result of the DispositionReport. Same as calling    * getErrInfoText(0). Will throw an ArrayIndexOutOfBoundsException    * if the results Vector is empty.   *   * @see #getErrInfoText(int)   */  public String getErrInfoText()  {    return getErrInfoText(0);  }  /**   * Returns the first result in the DispositionReport. Same as    * calling getResult(0). Will throw an ArrayIndexOutOfBoundsException   * if the results Vector is empty.   *   * @see #getResult(int)   */  public Result getResult()  {    return getResult(0);  }  /**   * Returns the number of result elements contained within   * the DispositionReport. This value can be used to conveniently   * get specifc information using the getXxx(int index) methods.   *   * @see #getErrCode(int)   * @see #getErrInfoText(int)   * @see #getErrno(int)   * @see #getResult(int)   */  public int getNumResults()  {    if (this.resultVector != null)      return this.resultVector.size();    else      return 0;  }  /**   * Returns the value of the "errno" attribute from the result   * element located at position "index" in the result Vector.   *   * @param index An integer representing the location of the   *              result element in the result Vector.   *   * @see #getErrno()   */  public int getErrno(int index)  {    Result result = (Result)this.resultVector.elementAt(index);    return Integer.parseInt(result.getErrno());  }  /**   * Returns the value of the "errCode" attribute of the ErrInfo   * element of the result element located at position "index"   * in the result Vector.   *   * @param index An integer representing the location of the   *              result element in the result Vector.   *   * @see #getErrCode()   */  public String getErrCode(int index)  {    Result result = (Result)this.resultVector.elementAt(index);    ErrInfo errinfo = result.getErrInfo();    return errinfo.getErrCode();  }  /**   * Returns the text value of the ErrInfo element of the result   * element located at position "index" in the result Vector.   *   * @param index An integer representing the location of the   *              result element in the result Vector.   *   * @see #getErrInfoText()   */  public String getErrInfoText(int index)  {    Result result = (Result)this.resultVector.elementAt(index);    ErrInfo errinfo = result.getErrInfo();    return errinfo.getText();  }  /**   * Returns the result element located at position "index" in   * the result Vector.   *   * @param index An integer representing the location of the   *              result element in the result Vector.   *   * @see #getResult()   */  public Result getResult(int index)  {    return (Result)this.resultVector.elementAt(index);  }  /**   * Returns true if all results contain an "errno"   * value of success (0).   */  public boolean success()  {    // take a look at the errno values for all results    for (int i=0; i<resultVector.size(); i++)    {      Result result = (Result)this.resultVector.elementAt(i);      if (result != null) {        int errno = Integer.parseInt(result.getErrno());        if (errno != 0)          return false;      }    }    return true;  }  /**   * Sets the value of the DispositionReport's "generic" attribute.   *   * @param gen New value of the DispositionReport's   *            generic attribute.   *   * @see #getGeneric()   */  public void setGeneric(String gen)  {    this.generic = gen;  }  /**   * Sets the value of the DispositionReport's "operator" attribute.   *   * @param oper New value of the DispositionReport's   *             operator attribute.   *   * @see #getOperator()   */  public void setOperator(String oper)  {    this.operator = oper;  }  /**   * Sets a Vector of result elements in the DispositionReport   * replacing the current Vector.   *   * @param index A Vector of result objects.   *   * @see #getResults()   */  public void setResults(Vector res)  {    if (res == null)      this.resultVector = new Vector(); // a new empty Vector    else      this.resultVector = res;  }  /**   * Tests the passed in element to determine if the   * element is a serialized version of this object.   *   * @param el Root element for this object   */  public boolean isValidElement(Element el)  {    return el.getNodeName().equals(UDDI_TAG);  }  /**   * Saves this DispostionReport as a child element   * to the parent element parameter.   *   * @param parent The Element which to save this   *               DispositionReport under.   */  public void saveToXML(Element parent)  {    base = parent.getOwnerDocument().createElement(UDDI_TAG);    // save DispositionReport attributes    if (this.generic != null)      base.setAttribute("generic",this.generic);    base.setAttribute("xmlns",org.uddi4j.UDDIElement.XMLNS);    if (this.operator != null)      base.setAttribute("operator",this.operator);    // save the results elements    if (this.resultVector != null) {      for (int i=0; i < resultVector.size(); i++) {        ((Result)(resultVector.elementAt(i))).saveToXML(base);      }    }    parent.appendChild(base);  }  /***************************************************************************/  /***************************** TEST DRIVER *********************************/  /***************************************************************************/  /*  public static String toString(DispositionReport dispRpt)  {    StringBuffer buffer = new StringBuffer();    buffer.append("dispositionReport.generic="+dispRpt.getGeneric()+"\n");    buffer.append("dispositionReport.operator="+dispRpt.getOperator()+"\n");    buffer.append("dispositionReport.result.errno="+dispRpt.getErrno()+"\n");    buffer.append("dispositionReport.result.keyType="+dispRpt.getKeyType()+"\n");    buffer.append("dispositionReport.result.errCode="+dispRpt.getErrCode()+"\n");    buffer.append("dispositionReport.result.errInfoText="+dispRpt.getErrInfoText()+"\n");        Vector resultVector = dispRpt.getResults();    if ((resultVector != null) && (resultVector.size() > 0))    {      buffer.append("dispositionReport.result.count="+resultVector.size()+"\n");            for (int i=0; i<resultVector.size(); i++)      {        Result result = (Result)resultVector.elementAt(i);        buffer.append("dispositionReport.result"+i+".keyType="+result.getKeyType()+"\n");        buffer.append("dispositionReport.result"+i+".errno="+result.getErrno()+"\n");         ErrInfo errInfo = result.getErrInfo();        if (errInfo != null)        {          buffer.append("dispositionReport.result"+i+".errInfo.errCode="+errInfo.getErrCode()+"\n");          buffer.append("dispositionReport.result"+i+".errInfo.text="+errInfo.getText()+"\n");        }        else          buffer.append("dispositionReport.result"+i+".errInfo=null\n");        }    }    else    {      buffer.append("dispositionReport.results=0\n");    }        return buffer.toString();  }      public static void main(String[] args)    throws Exception  {    Result result = null;    ErrInfo errinfo = null;    Vector resultVector = new Vector();    errinfo = new ErrInfo();    errinfo.setErrCode(DispositionReport.E_fatalError);    errinfo.setText("A serious technical error has occured");    result = new Result();    //result.setErrno("0"); // <-for testing success() method    result.setErrno("10500");    result.setErrInfo(errinfo);    result.setKeyType("");    resultVector.add(result);    errinfo = new ErrInfo();    errinfo.setErrCode(DispositionReport.E_unsupported);    errinfo.setText("Feature or API is unsupported");    result = new Result();    //result.setErrno("0"); // <-for testing success() method    result.setErrno("10050");    result.setErrInfo(errinfo);    result.setKeyType("");    resultVector.add(result);        DispositionReport dispRpt1 = new DispositionReport();    dispRpt1.setGeneric(DispositionReport.GENERIC);    dispRpt1.setOperator("uddi4j.org");    dispRpt1.setResults(resultVector);        javax.xml.parsers.DocumentBuilderFactory factory =       javax.xml.parsers.DocumentBuilderFactory.newInstance();    javax.xml.parsers.DocumentBuilder docBuilder =       factory.newDocumentBuilder();    org.w3c.dom.Document doc = docBuilder.newDocument();    org.w3c.dom.Element parent = doc.createElement("parent");        dispRpt1.saveToXML(parent);        DispositionReport dispRpt2 = new DispositionReport((Element)parent.getFirstChild());    System.out.println("------------------------------------------------------------");    System.out.println(toString(dispRpt1));    System.out.println("------------------------------------------------------------");    System.out.println(toString(dispRpt2));    System.out.println("------------------------------------------------------------");    System.out.println("The two are equal: "+toString(dispRpt2).equals(toString(dispRpt2)));    System.out.println("------------------------------------------------------------");    System.out.println("Successful? = "+dispRpt1.success());    System.out.println("------------------------------------------------------------");        System.out.println("getErrno Test: \n" +      "   getErrno()            = " + dispRpt1.getErrno() + "\n" +      "   getErrno(index)       = " + dispRpt1.getErrno(0)+"\n" +      "   pass/fail?            = " + ((dispRpt1.getErrno()==dispRpt1.getErrno(0)) ? "pass\n" : "fail\n"));    System.out.println("getErrInfoText Test: \n" +      "   getErrInfoText()      = " + dispRpt1.getErrInfoText() + "\n" +      "   getErrInfoText(index) = " + dispRpt1.getErrInfoText(0)+"\n" +      "   pass/fail?            = " + (dispRpt1.getErrInfoText().equals(dispRpt1.getErrInfoText(0)) ? "pass\n" : "fail\n"));    System.out.println("getErrCode Test: \n" +      "   getErrCode()          = " + dispRpt1.getErrCode() + "\n" +      "   getErrCode(index)     = " + dispRpt1.getErrCode(0)+"\n" +      "   pass/fail?            = " + (dispRpt1.getErrCode().equals(dispRpt1.getErrCode(0)) ? "pass\n" : "fail\n"));    System.out.println("getKeyType Test: \n" +      "   getKeyType()          = " + dispRpt1.getKeyType() + "\n" +      "   getKeyType(index)     = " + dispRpt1.getKeyType(0)+"\n" +      "   pass/fail?            = " + (dispRpt1.getKeyType().equals(dispRpt1.getKeyType(0)) ? "pass\n" : "fail\n"));          System.out.println("");    int numResults = dispRpt2.getNumResults();    for (int i=0; i<numResults; i++)    {      System.out.println("dispRpt2.getErrno:               "+dispRpt2.getErrno(i));      System.out.println("dispRpt2.getErrCode:             "+dispRpt2.getErrCode(i));      System.out.println("dispRpt2.getErrInfoText:         "+dispRpt2.getErrInfoText(i));      System.out.println("dispRpt2.getKeyType:             "+dispRpt2.getKeyType(i));      System.out.println("");            Result result2 = dispRpt2.getResult(i);      System.out.println("result.getErrno:                 "+result2.getErrno());      System.out.println("result.getKeyType:               "+result2.getKeyType());      ErrInfo errinfo2 = result2.getErrInfo();      System.out.println("result2.errinfo.getErrCode:      "+errinfo2.getErrCode());      System.out.println("result2.errinfo.getErrInfoText:  "+errinfo2.getText());          System.out.println("");    }  }  */}